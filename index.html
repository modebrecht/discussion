<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Classroom Discussion Board</title>
  <style>
    /* ===== Theme tokens (PAP style) ===== */
    :root{
      --bg:#f6f7fb;
      --ink:#1f2937;
      --muted:#6b7280;
      --accent:#16a34a;    /* green */
      --accent-2:#06b6d4;  /* cyan */
      --panel:#46474A;     /* anthracite */
      --panel-ink:#f1f5f9; /* light ink on panel */
      --shadow:0 10px 30px rgba(0,0,0,.08);
      --ring: 0 0 0 3px rgba(6, 182, 212, .35);
      --radius: 12px;
      --radius-lg: 16px;
      --radius-xl: 20px;
      --chip-font-scale: 1;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      min-height:100vh; margin:0; background:var(--bg); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    /* Header / toolbar */
    .toolbar{background:#fff; box-shadow:var(--shadow);}
    .toolbar-inner{max-width:64rem; margin:0 auto; padding:.75rem 1rem; display:flex; align-items:center; gap:.75rem}
    .logo-pill{height:24px; width:24px; border-radius:12px; display:grid; place-items:center; font:600 12px/1.1 ui-sans-serif; background:var(--panel); color:var(--panel-ink)}
    .title{font-weight:600; font-size:1.125rem; letter-spacing:.01em}
    .font-controls{margin-inline-start:auto; display:flex; align-items:center; gap:.5rem}
    .font-pct{opacity:.9; font-size:.75rem; line-height:1}

    /* Layout */
    .container{max-width:64rem; margin:0 auto; padding:0 1rem 4rem}
    .card{margin-top:2rem; border:1px solid #e5e7eb; background:#fff; border-radius:var(--radius-lg); box-shadow:0 1px 2px rgba(0,0,0,.04)}
    .card-body{padding:1rem}
    .input-row{display:flex; flex-wrap:wrap; align-items:center; gap:.75rem}
    .grow{flex:1 1 280px}
    .options-row{margin-top:.75rem; display:flex; flex-wrap:wrap; align-items:center; gap:1rem}
    .control-group{display:inline-flex; align-items:center; gap:.5rem}
    .spacer{margin-inline-start:auto}

    /* Inputs and buttons */
    .input{width:100%; border:1px solid #d1d5db; border-radius:var(--radius); padding:.75rem 1rem; font-size:1rem; background:#fff; color:var(--ink)}
    .input:focus{outline:none; border-color:#22d3ee; box-shadow:var(--ring)}

    .btn{border:1px solid #e5e7eb; background:#f9fafb; color:#111827; border-radius:var(--radius); padding:.4rem .65rem; font-size:.875rem; font-weight:600; line-height:1.1; cursor:pointer}
    .btn:hover{background:#f3f4f6}
    .btn:focus{outline:none; box-shadow:var(--ring)}
    .btn-primary{border-color:#9ee6f1; background:#e6fafd; color:#036c7d}
    .btn-primary:hover{background:#d8f6fb}

    .label{display:inline-flex; align-items:center; gap:.5rem; font-size:.875rem; user-select:none; color:#374151}

    kbd{border:1px solid #d1d5db; border-radius:6px; padding:0 .25rem; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.85em}

    /* Chip list */
    #list{
      position:relative;
      width:100%;
      min-height:0;
      padding:6px;
    }

    .chip{border:1px solid #e5e7eb; background:#fff; color:#1f2937; border-radius:18px; padding:calc(.5rem * var(--chip-font-scale, 1)) calc(1rem * var(--chip-font-scale, 1)); font-size:calc(.95rem * var(--chip-font-scale, 1)); font-weight:500; box-shadow:0 1px 2px rgba(0,0,0,.05); transition: padding .22s ease, font-size .22s ease, box-shadow .22s ease, background-color .22s ease, border-color .22s ease, transform .12s ease}
    .chip:hover{box-shadow:0 6px 16px rgba(0,0,0,.08); transform:translateY(-1px); border-color:#67e8f9; background:#ecfeff}
    .chip:focus{outline:none; box-shadow:var(--ring)}
    .chip-colored:hover{filter:brightness(1.08)}

    /* Grow behavior for spotlight (no overlap) */
    .btn-item{transform-origin:center center}
    .btn-wrap{
      position:absolute;
      display:block;
      margin:0;
      top:0;
      left:0;
      transform-origin:top left;
      transition:transform .22s ease;
      will-change:transform;
    }

    /* Tooltip */
    .hint{position:relative}
    .hint::after{content:attr(data-hint); position:absolute; inset-inline-start:0; inset-block-start:100%; margin-top:.35rem; white-space:nowrap; padding:.25rem .5rem; border-radius:6px; background:rgba(17,24,39,.9); color:#fff; font-size:.75rem; opacity:0; transform:translateY(-2px); pointer-events:none; transition:all .16s ease}
    .hint:hover::after{opacity:1; transform:translateY(0)}

    /* A11y helpers */
    .sr-only{position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
  </style>
</head>
<body>
  <!-- Top bar / Toolbar -->
  <header class="toolbar">
    <div class="toolbar-inner">
      <div style="display:flex; align-items:center; gap:.5rem">
        <div class="logo-pill" title="Theme accent">D</div>
        <h1 class="title">Discussion Board</h1>
      </div>
      <div class="font-controls">
        <button id="decFont" class="btn hint" data-hint="Smaller font (F-)" type="button">F-</button>
        <button id="incFont" class="btn hint" data-hint="Larger font (F+)" type="button">F+</button>
        <span class="font-pct">Font: <strong id="fontPct">100%</strong></span>
      </div>
    </div>
  </header>

  <!-- Main -->
  <main class="container">
    <section class="card">
      <div class="card-body">
        <div class="input-row">
          <label for="topicInput" class="sr-only">Add discussion item</label>
          <input id="topicInput" class="input grow" type="text" autocomplete="off" placeholder="Type an item and press Enter..." />
          <button id="addBtn" type="button" class="btn btn-primary">Add</button>
        </div>
        <div class="options-row">
          <div class="control-group" style="flex-wrap:wrap; gap:.75rem">
            <label class="label" title="Give new chips a random background color"><input id="randColor" type="checkbox" checked> Color</label>
            <label class="label" title="Automatically prepend an emoji based on the text"><input id="autoEmoji" type="checkbox"> Emoji</label>
            <button id="reEmoji" type="button" title="Re-scan all chips and prepend emojis where missing" class="btn">Re-emoji</button>
            <button id="decFont2" type="button" class="btn" title="Smaller chip font">F-</button>
            <button id="incFont2" type="button" class="btn" title="Larger chip font">F+</button>
            <label class="label" style="gap:.35rem" title="Adjust pill base size"><span>Size</span>
              <input id="chipSize" type="range" min="0.6" max="6" step="0.005" value="1" />
            </label>
            <label class="label" style="gap:.35rem" title="Adjust spacing between pills"><span>Spacing</span>
              <input id="chipMargin" type="range" min="0" max="32" step="1" value="8" />
            </label>
            <button id="masonryToggle" type="button" class="btn" title="Toggle dense masonry packing for chips">Masonry</button>
            <button id="exportBtn" type="button" class="btn" title="Download chips as a file">Export</button>
            <button id="importBtn" type="button" class="btn" title="Import chips from a file">Import</button>
            <input id="importFile" type="file" accept="application/json" style="display:none">
          </div>
        </div>
      </div>
    </section>

    <section style="margin-top:1.5rem">
      <div id="list"></div>
    </section>
  </main>

  <script>
    // ===== DOM refs =====
    const list = document.getElementById('list');
    const input = document.getElementById('topicInput');
    const addBtn = document.getElementById('addBtn');
    const randToggle = document.getElementById('randColor');
    const emojiToggle = document.getElementById('autoEmoji');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const importFileInput = document.getElementById('importFile');
    const masonryToggleBtn = document.getElementById('masonryToggle');
    const chipSizeInput = document.getElementById('chipSize');
    const chipMarginInput = document.getElementById('chipMargin');

    const STORAGE_KEY = 'discussion.chips.v1';
    const SETTINGS_KEY = 'discussion.settings.v1';
    const EXPORT_FILENAME = 'discussion-chips.json';
    const layoutConfig = { step: 4, gutter: 8, chipScale: 1, mode: 'flow' };
    const SPOTLIGHT_STEPS = [0, 0.3, 0.6, 0.9];
    const raf = (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function')
      ? window.requestAnimationFrame.bind(window)
      : (cb) => setTimeout(cb, 16);
    const chipResizeObserver = (typeof ResizeObserver !== 'undefined')
      ? new ResizeObserver(() => scheduleLayout())
      : null;
    let chipSequence = 0;
    let layoutScheduled = false;
    const storage = (() => {
      try { return typeof localStorage !== 'undefined' ? localStorage : null; }
      catch (_) { return null; }
    })();

    const readStorage = (key) => {
      if (!storage) return null;
      try { return storage.getItem(key); }
      catch (err) { console.warn('Local storage read failed:', err); return null; }
    };

    const writeStorage = (key, value) => {
      if (!storage) return;
      try { storage.setItem(key, value); }
      catch (err) { console.warn('Local storage save failed:', err); }
    };
    const removeStorage = (key) => {
      if (!storage) return;
      try { storage.removeItem(key); }
      catch (err) { console.warn('Local storage remove failed:', err); }
    };

    const defaultSettings = { chipScale: 1, gutter: 8 };
    const sliderBounds = {
      size: chipSizeInput ? {
        min: parseFloat(chipSizeInput.min) || defaultSettings.chipScale,
        max: parseFloat(chipSizeInput.max) || defaultSettings.chipScale,
        step: parseFloat(chipSizeInput.step) || 0.005
      } : { min: defaultSettings.chipScale, max: defaultSettings.chipScale, step: 0.005 },
      margin: chipMarginInput ? {
        min: parseFloat(chipMarginInput.min) || defaultSettings.gutter,
        max: parseFloat(chipMarginInput.max) || defaultSettings.gutter,
        step: parseFloat(chipMarginInput.step) || 1
      } : { min: defaultSettings.gutter, max: defaultSettings.gutter, step: 1 }
    };

    const clampNumber = (value, min, max) => Math.min(max, Math.max(min, value));

    function loadSettings(){
      const raw = readStorage(SETTINGS_KEY);
      if(!raw) return { ...defaultSettings };
      try{
        const parsed = JSON.parse(raw);
        return { ...defaultSettings, ...parsed };
      }catch(err){
        console.warn('Settings parse failed:', err);
        return { ...defaultSettings };
      }
    }

    let settingsReady = false;

    function persistSettings(){
      if(!settingsReady) return;
      const payload = {
        chipScale: Number(chipScale.toFixed(3)),
        gutter: Math.round(layoutConfig.gutter)
      };
      writeStorage(SETTINGS_KEY, JSON.stringify(payload));
    }

    const uiSettings = loadSettings();
    layoutConfig.gutter = clampNumber(uiSettings.gutter, sliderBounds.margin.min, sliderBounds.margin.max);
    layoutConfig.step = Math.max(2, Math.min(8, Math.round(layoutConfig.gutter / 2))) || layoutConfig.step;
    if(chipMarginInput) chipMarginInput.value = String(Math.round(layoutConfig.gutter));

    function layoutMasonry(wraps, {
      padLeft,
      padTop,
      padBottom,
      availableWidth,
      gutter
    }){
      const unit = Math.max(1, Math.round(layoutConfig.step || 4));
      const columns = Math.max(1, Math.floor((availableWidth + gutter) / unit));
      const columnHeights = new Array(columns).fill(0);
      let maxBottom = 0;

      wraps.forEach(wrap => {
        if(!(wrap instanceof HTMLElement)) return;
        const chip = wrap.firstElementChild instanceof HTMLElement ? wrap.firstElementChild : null;
        const itemWidth = chip ? chip.offsetWidth : wrap.offsetWidth;
        const itemHeight = chip ? chip.offsetHeight : wrap.offsetHeight;
        if(itemWidth <= 0 || itemHeight <= 0) return;

        const unitsNeeded = Math.min(columns, Math.max(1, Math.ceil((itemWidth + gutter) / unit)));
        let bestIndex = 0;
        let bestHeight = Number.POSITIVE_INFINITY;
        const searchLimit = columns - unitsNeeded;

        for(let i = 0; i <= searchLimit; i++){
          let spanHeight = 0;
          for(let j = i; j < i + unitsNeeded; j++){
            spanHeight = Math.max(spanHeight, columnHeights[j]);
            if(spanHeight >= bestHeight) break;
          }
          if(spanHeight < bestHeight){
            bestHeight = spanHeight;
            bestIndex = i;
            if(bestHeight === 0) break;
          }
        }

        const finalLeft = padLeft + bestIndex * unit;
        const finalTop = padTop + bestHeight;
        wrap.style.transform = `translate3d(${finalLeft}px, ${finalTop}px, 0)`;

        const newHeight = bestHeight + itemHeight + gutter;
        for(let j = bestIndex; j < bestIndex + unitsNeeded; j++){
          columnHeights[j] = newHeight;
        }
        maxBottom = Math.max(maxBottom, bestHeight + itemHeight);
      });

      const totalHeight = padTop + Math.max(0, maxBottom + padBottom);
      return totalHeight;
    }

    function layoutChipsNow(){
      if(!list) return;
      const wraps = Array.from(list.children).filter(node => node instanceof HTMLElement);
      if(!wraps.length){
        list.style.height = '0px';
        return;
      }
      const { gutter } = layoutConfig;
      const styles = (typeof window !== 'undefined' && window.getComputedStyle)
        ? window.getComputedStyle(list)
        : null;
      const padLeft = styles ? parseFloat(styles.paddingLeft) || 0 : 0;
      const padRight = styles ? parseFloat(styles.paddingRight) || 0 : 0;
      const padTop = styles ? parseFloat(styles.paddingTop) || 0 : 0;
      const padBottom = styles ? parseFloat(styles.paddingBottom) || 0 : 0;
      const rawWidth = list.clientWidth - padLeft - padRight;
      if(rawWidth <= 0){
        list.style.height = '0px';
        return;
      }
      const availableWidth = Math.max(1, rawWidth);

      if(layoutConfig.mode === 'masonry'){
        const totalHeight = layoutMasonry(wraps, {
          padLeft,
          padTop,
          padBottom,
          availableWidth,
          gutter
        });
        list.style.height = totalHeight + 'px';
        return;
      }

      let cursorX = 0;
      let cursorY = 0;
      let rowHeight = 0;
      let maxBottom = 0;
      // Lay chips row by row in DOM order so entries stay chronological.
      wraps.forEach(wrap => {
        if(!(wrap instanceof HTMLElement)) return;
        const chip = wrap.firstElementChild instanceof HTMLElement ? wrap.firstElementChild : null;
        // Measure the interactive button itself so spacing stays accurate while wraps animate.
        const itemWidth = chip ? chip.offsetWidth : wrap.offsetWidth;
        const itemHeight = chip ? chip.offsetHeight : wrap.offsetHeight;
        if(cursorX > 0 && cursorX + itemWidth > availableWidth){
          cursorX = 0;
          cursorY += rowHeight + gutter;
          rowHeight = 0;
        }
        const finalLeft = padLeft + cursorX;
        const finalTop = padTop + cursorY;
        wrap.style.transform = `translate3d(${finalLeft}px, ${finalTop}px, 0)`;
        cursorX += itemWidth + gutter;
        rowHeight = Math.max(rowHeight, itemHeight);
        maxBottom = Math.max(maxBottom, cursorY + itemHeight);
      });
      const totalHeight = padTop + Math.max(0, maxBottom + padBottom);
      list.style.height = totalHeight + 'px';
    }

    function scheduleLayout(){
      if(layoutScheduled) return;
      layoutScheduled = true;
      raf(() => {
        layoutScheduled = false;
        layoutChipsNow();
      });
    }

    if(list){
      window.addEventListener('resize', scheduleLayout);
    }

    const isTypingContext = (el) => {
      if (!el) return false;
      if (el.isContentEditable) return true;
      const tag = el.tagName;
      return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
    };

    function refreshChipMetrics(){
      if (!list) return;
      const buttons = Array.from(list.querySelectorAll('.btn-item'));
      buttons.forEach(btn => {
        const stage = Number(btn.dataset.scaleStage || '0');
        applyStageToChip(btn, stage, { remeasure: true });
        if(chipResizeObserver) chipResizeObserver.observe(btn);
      });
      scheduleLayout();
    }

    // ===== Font toolbar =====
    const fontPct = document.getElementById('fontPct');
    const chipScaleStep = 0.125;
    const chipScaleMin = sliderBounds.size.min;
    const chipScaleMax = 6;
    const sizeStep = sliderBounds.size.step || 0.005;
    let chipScale = clampNumber(uiSettings.chipScale, sliderBounds.size.min, sliderBounds.size.max);
    chipScale = Math.round(chipScale / sizeStep) * sizeStep;
    layoutConfig.chipScale = chipScale;
    if(chipSizeInput) chipSizeInput.value = chipScale.toFixed(3);

    const applyChipScale = () => {
      document.documentElement.style.setProperty('--chip-font-scale', chipScale.toString());
      layoutConfig.chipScale = chipScale;
      if (chipSizeInput && document.activeElement !== chipSizeInput){
        chipSizeInput.value = chipScale.toFixed(3);
      }
      if (fontPct) fontPct.textContent = Math.round(chipScale * 100) + '%';
      refreshChipMetrics();
    };

    const adjustChipScale = (delta) => {
      const nextRaw = Number((chipScale + delta).toFixed(4));
      const next = Math.min(chipScaleMax, Math.max(chipScaleMin, nextRaw));
      if (next === chipScale) return;
      chipScale = next;
      applyChipScale();
      persistSettings();
    };

    const incFontBtn = document.getElementById('incFont');
    const decFontBtn = document.getElementById('decFont');
    const incFont2 = document.getElementById('incFont2');
    const decFont2 = document.getElementById('decFont2');
    if (incFontBtn) incFontBtn.addEventListener('click', () => adjustChipScale(chipScaleStep));
    if (decFontBtn) decFontBtn.addEventListener('click', () => adjustChipScale(-chipScaleStep));
    if (incFont2) incFont2.addEventListener('click', () => adjustChipScale(chipScaleStep));
    if (decFont2) decFont2.addEventListener('click', () => adjustChipScale(-chipScaleStep));
    applyChipScale();

    const updateGutter = (value) => {
      const clamped = Math.round(clampNumber(value, sliderBounds.margin.min, sliderBounds.margin.max));
      if(clamped === Math.round(layoutConfig.gutter) && Math.abs(clamped - layoutConfig.gutter) < 0.5) return false;
      layoutConfig.gutter = clamped;
      layoutConfig.step = Math.max(2, Math.min(8, Math.round(layoutConfig.gutter / 2))) || layoutConfig.step;
      if(chipMarginInput){
        chipMarginInput.value = String(clamped);
      }
      scheduleLayout();
      return true;
    };

    if (chipSizeInput){
      chipSizeInput.addEventListener('input', () => {
        const raw = parseFloat(chipSizeInput.value);
        if (!Number.isFinite(raw)) return;
        const clamped = clampNumber(raw, sliderBounds.size.min, sliderBounds.size.max);
        const snapped = Math.round(clamped / sizeStep) * sizeStep;
        if (!Number.isFinite(snapped) || Math.abs(snapped - chipScale) < 1e-4) return;
        chipSizeInput.value = snapped.toFixed(3);
        chipScale = snapped;
        applyChipScale();
        persistSettings();
      });
    }

    if (chipMarginInput){
      chipMarginInput.addEventListener('input', () => {
        const value = parseFloat(chipMarginInput.value);
        if(!Number.isFinite(value)) return;
        if(updateGutter(value)) persistSettings();
      });
    }

    // ===== Hotkeys =====
    document.addEventListener('keydown', (e) => {
      if (isTypingContext(e.target) || e.altKey || e.ctrlKey || e.metaKey) return;
      const key = e.key ? e.key.toLowerCase() : '';
      if (key === 'q') {
        e.preventDefault();
        adjustChipScale(-chipScaleStep);
      } else if (key === 'w') {
        e.preventDefault();
        adjustChipScale(chipScaleStep);
      } else if (key === 'e') {
        if (!input) return;
        e.preventDefault();
        input.focus();
        if (typeof input.select === 'function') input.select();
      }
    });

    // ===== Color utilities =====
    function randomColorHex(){ return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0'); }
    function hexToRgb(hex){ const n = parseInt(hex.slice(1),16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 }; }
    function srgbToLinear(u){ const c=u/255; return c<=0.03928? c/12.92 : Math.pow((c+0.055)/1.055,2.4); }
    function luminance(rgb){ const {r,g,b}=rgb; return 0.2126*srgbToLinear(r)+0.7152*srgbToLinear(g)+0.0722*srgbToLinear(b); }
    function shade(hex,percent){ const {r,g,b}=hexToRgb(hex); const f=v=>Math.min(255,Math.max(0,Math.round(v+(percent/100)*255))); const rr=f(r),gg=f(g),bb=f(b); return '#'+((1<<24)+(rr<<16)+(gg<<8)+bb).toString(16).slice(1).toUpperCase(); }
    function setChipColor(btn, hex){
      btn.style.backgroundColor = hex;
      btn.classList.add('chip-colored');
      const L = luminance(hexToRgb(hex));
      const contrastBlack = (L+0.05)/0.05; const contrastWhite = 1.05/(L+0.05); const useBlack = contrastBlack>=contrastWhite;
      btn.style.color = useBlack ? '#111827' : '#FFFFFF';
      btn.style.borderColor = useBlack ? shade(hex,-20) : shade(hex,20);
      btn.dataset.color = hex;
    }
    function clearChipColor(btn){
      btn.style.backgroundColor = '';
      btn.style.color = '';
      btn.style.borderColor = '';
      btn.classList.remove('chip-colored');
      delete btn.dataset.color;
    }

    // ===== Emoji utilities =====
    function startsWithEmoji(str){ const s=(str||'').trim(); if(!s) return false; const cp=s.codePointAt(0); return (cp>=0x1F300&&cp<=0x1FAFF)||(cp>=0x2600&&cp<=0x27BF); }
    function norm(s){ return (s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
    function hasAny(label,words){
      const l=norm(label);
      return words.some(w=> {
        if(!w) return false;
        return l.includes(norm(w));
      });
    }

    const emojiRules = [
      { words:['?'], e:'❓' }, { words:['!'], e:'❗' },
      { words:['webseite','website','homepage','web'], e:'🌐' },
      { words:['youtube','yt'], e:'▶️' }, { words:['tiktok','tik tok'], e:'🎵' },
      { words:['social','social-media','post'], e:'💬' }, { words:['app','apps'], e:'📱' }, { words:['online-shop','checkout','online-shopping'], e:'🛒' },
      { words:['computer','pc','laptop','it','programm','programmieren','coding','code','javascript','html','css'], e:'💻' },
      { words:['smartphone','handy','mobile','telefon','phone','handy-face-unlock','face-unlock'], e:'📱' },
      { words:['kamera','camera','smartphone-kamera','hdr'], e:'📷' },
      { words:['drucker','printer'], e:'🖨️' }, { words:['3d-drucker','3d drucker','3ddrucker','3dprinter'], e:'🖨️' },
      { words:['scanner + ocr','ocr'], e:'🔤' }, { words:['scanner','scan'], e:'📠' }, { words:['kopierer','copy'], e:'🖨️' },
      { words:['smartwatch','fitness-tracker','tracker','fitnesstracker'], e:'⌚' }, { words:['lautsprecher','speaker'], e:'🔊' },
      { words:['kopfhoerer','kopfhörer','kopfhore','kopfhöhrer','headphones','headset'], e:'🎧' },
      { words:['lampe','licht','smart-licht'], e:'💡' }, { words:['smart-plug','steckdose','steckdosenstecker'], e:'🔌' },
      { words:['smart-waage','waage'], e:'⚖️' }, { words:['wlan','wifi','router','netzwerk','network','lan','netz'], e:'📶' },
      { words:['gps-gerät','gps','gps-navigation','navigation'], e:'🧭' }, { words:['gegenstands-tracker','airtag','tile','tracker tag'], e:'📍' },
      { words:['fingerabdrucksensor','fingerprint','biometrie','biometric'], e:'🔒' }, { words:['keycard-tür','keycard','rfid-tür'], e:'🔐' },
      { words:['captcha','captcha-prüfung'], e:'🤖' }, { words:['e-mail-spamfilter','spam','spamfilter'], e:'🚫' },
      { words:['kühlschrank','kuehlschrank','fridge'], e:'🧊' }, { words:['gefrierschrank','freezer'], e:'🧊' },
      { words:['herd','kochen','ofen','backofen'], e:'🍳' }, { words:['mikrowelle','microwave'], e:'🍽️' },
      { words:['geschirrspüler','geschirrspueler','geschirrspuler','spülmaschine','spuelmaschine','spulmaschine','spueler','spuler'], e:'🍽️' },
      { words:['waschmaschine','trockner'], e:'🧺' }, { words:['kaffeeautomat','kaffeemaschine','kaffemaschine','kaffee','espresso'], e:'☕' },
      { words:['fernseher','tv'], e:'📺' }, { words:['thermostat','raum-thermostat','heizung'], e:'🌡️' }, { words:['rauchmelder','co2-melder','melder'], e:'🚨' },
      { words:['luftbefeuchter','humidifier'], e:'💧' }, { words:['smart-licht','straßenlaterne','strassenlaterne'], e:'💡' },
      { words:['bankautomat','atm'], e:'🏧' }, { words:['nfc-bezahlterminal','nfc','bezahlen','kredit-scoring','kredit','zahlung','bezahlung','terminal'], e:'💳' },
      { words:['lift','aufzug'], e:'🛗' }, { words:['auto','fahrzeug','fahrzeugmotor'], e:'🚗' }, { words:['abstands-tempomat','tempomat','acc'], e:'🚘' },
      { words:['ampel','verkehr'], e:'🚦' }, { words:['fahrkartenautomat','ticketautomat','fahrkarte'], e:'🎫' }, { words:['parkhaus-schranke','schranke'], e:'🚧' },
      { words:['parkuhr-app','parkuhr','parking'], e:'🅿️' }, { words:['verkehrskontrolle','verkehrsradar','blitzer'], e:'🚓' },
      { words:['e-ladestation','ladestation','ladestelle'], e:'🔌' }, { words:['solarpanel','pv','pv-wechselrichter','wechselrichter'], e:'☀️' }, { words:['windkraftanlage','wind'], e:'🌬️' },
      { words:['bewässerungssystem','bewaesserung','bewasserung'], e:'💧' }, { words:['landwirtschaft','agri'], e:'🌾' }, { words:['recycling-anlage','recycling'], e:'♻️' }, { words:['wasseraufbereitung'], e:'💧' },
      { words:['gesundheitswesen','patientenmonitor'], e:'🏥' }, { words:['thermometer'], e:'🌡️' }, { words:['blutdruckmessgerät','blutdruck'], e:'🩺' }, { words:['immunsystem'], e:'🛡️' }, { words:['sensor'], e:'📡' },
      { words:['kasse im supermarkt','supermarkt-kasse','kasse'], e:'🛒' }, { words:['packstation','paket-tracking','paket','tracking'], e:'📦' }, { words:['bibliotheks-ausleihautomat','ausleihautomat','bibliothek'], e:'📚' },
      { words:['schule','schule/bildung','bildung','studieren','lernen','lesson','chapter'], e:'📚' }, { words:['musik-empfehlung','musik','music','song','lied'], e:'🎵' }, { words:['übersetzungs-app','uebersetzungs-app','translate','translator','translation'], e:'🌐' },
      { words:['pizza'], e:'🍕' }, { words:['farbe','color','paint','malen'], e:'🎨' }, { words:['haus','home','zuhause','wohnung'], e:'🏠' }, { words:['tanzen','dance'], e:'💃' }
    ];

    function detectEmoji(label){ if(label.includes('?')) return '❓'; if(label.includes('!')) return '❗'; for(const r of emojiRules) if(hasAny(label,r.words)) return r.e; return ''; }
    function maybeAddEmoji(label){ if(!emojiToggle||!emojiToggle.checked) return label; if(startsWithEmoji(label)) return label; const em=detectEmoji(label); return em? (em+' '+label):label; }

    // ===== Chip helpers =====
    function clearChipInlineSizing(btn){
      if(!(btn instanceof HTMLElement)) return;
      const { style } = btn;
      style.fontSize = '';
      style.paddingLeft = '';
      style.paddingRight = '';
      style.paddingTop = '';
      style.paddingBottom = '';
    }

    function forceChipStyleSync(btn){
      if(!(btn instanceof HTMLElement)) return;
      // Access layout to flush pending style updates before measuring.
      void btn.offsetWidth;
    }

    function suspendChipTransitions(btn){
      if(!(btn instanceof HTMLElement)) return () => {};
      const { style } = btn;
      const prev = style.transition;
      style.transition = 'none';
      // Flush so the no-transition state takes effect immediately.
      void btn.offsetWidth;
      return () => {
        style.transition = prev;
        // Flush again so re-enabled transitions apply to subsequent changes.
        void btn.offsetWidth;
      };
    }

    function updateBaseMetrics(btn){
      const stage = Number(btn.dataset.scaleStage || '0');
      const factor = 1 + (SPOTLIGHT_STEPS[stage] || 0);
      const cs = getComputedStyle(btn);
      const normalize = (value) => {
        const num = parseFloat(value);
        if(!Number.isFinite(num)) return 0;
        return num / (factor || 1);
      };
      btn.dataset.baseFont = String(normalize(cs.fontSize));
      btn.dataset.basePadLeft = String(normalize(cs.paddingLeft));
      btn.dataset.basePadRight = String(normalize(cs.paddingRight));
      btn.dataset.basePadTop = String(normalize(cs.paddingTop));
      btn.dataset.basePadBottom = String(normalize(cs.paddingBottom));
      btn.dataset.metrics='1';
    }

    function applyStageToChip(btn, stage, { remeasure = false } = {}){
      let next = Number(stage);
      if(!Number.isFinite(next) || next < 0 || next >= SPOTLIGHT_STEPS.length) next = 0;
      if(remeasure){
        const restoreTransitions = suspendChipTransitions(btn);
        clearChipInlineSizing(btn);
        forceChipStyleSync(btn);
        btn.dataset.scaleStage = '0';
        btn.dataset.metrics = '0';
        updateBaseMetrics(btn);
        restoreTransitions();
      }else if(btn.dataset.metrics!=='1'){
        updateBaseMetrics(btn);
      }
      btn.dataset.scaleStage = String(next);
      const factor = 1 + SPOTLIGHT_STEPS[next];
      const baseFont = Number(btn.dataset.baseFont);
      const basePadLeft = Number(btn.dataset.basePadLeft);
      const basePadRight = Number(btn.dataset.basePadRight);
      const basePadTop = Number(btn.dataset.basePadTop);
      const basePadBottom = Number(btn.dataset.basePadBottom);
      const style = btn.style;
      if(Math.abs(factor - 1) < 0.0001){
        clearChipInlineSizing(btn);
        return;
      }
      const format = (base) => {
        if(!Number.isFinite(base)) return '';
        const value = base * factor;
        if(Math.abs(value) < 1e-4) return '0px';
        const fixed = value.toFixed(3);
        const trimmed = fixed.replace(/\.?0+$/,'');
        return (trimmed === '' ? '0' : trimmed) + 'px';
      };
      style.fontSize = format(baseFont);
      style.paddingLeft = format(basePadLeft);
      style.paddingRight = format(basePadRight);
      style.paddingTop = format(basePadTop);
      style.paddingBottom = format(basePadBottom);
    }

    function cycleChipStage(btn){
      const current = Number(btn.dataset.scaleStage || '0');
      const next = (current + 1) % SPOTLIGHT_STEPS.length;
      updateBaseMetrics(btn);
      applyStageToChip(btn, next);
      scheduleLayout();
      saveChips();
    }

    function createChip(label, options = {}){
      const wrap=document.createElement('div');
      wrap.className='btn-wrap';
      wrap.style.transform='translate3d(0,0,0)';
      const providedOrder = options.createdAt;
      const numericOrder = Number(providedOrder);
      if(Number.isFinite(numericOrder)){
        wrap.dataset.createdAt = String(numericOrder);
        chipSequence = Math.max(chipSequence, numericOrder + 1);
      }else{
        wrap.dataset.createdAt = String(chipSequence++);
      }
      const btn=document.createElement('button'); btn.type='button'; btn.className='btn-item chip';
      btn.dataset.label = label;
      btn.dataset.scaleStage = '0';
      btn.dataset.metrics = '0';
      btn.textContent = maybeAddEmoji(label);
      if(typeof options.displayText === 'string') btn.textContent = options.displayText;
      if(chipResizeObserver) chipResizeObserver.observe(btn);
      btn.title='Click to cycle size (+30%, +60%, +90%, reset). Press Delete to remove';
      if(options.color){
        setChipColor(btn, options.color);
      }else if(!options.skipRandom && randToggle && randToggle.checked){
        setChipColor(btn, randomColorHex());
      }else{
        clearChipColor(btn);
      }
      btn.addEventListener('click',()=>{
        cycleChipStage(btn);
        btn.focus();
      });
      btn.addEventListener('keydown',(e)=>{
        if(e.key==='Enter'||e.key===' '){
          e.preventDefault();
          cycleChipStage(btn);
        } else if(e.key==='Delete'){
          e.preventDefault();
          const host=btn.closest('.btn-wrap');
          if(host){
            if(chipResizeObserver) chipResizeObserver.unobserve(btn);
            host.remove();
            scheduleLayout();
            saveChips();
          }
        }
      });
      wrap.appendChild(btn);
      return wrap;
    }

    function sortWrapsBy(compare){
      if(!list) return [];
      const wraps = Array.from(list.children).filter(node => node instanceof HTMLElement);
      wraps.sort(compare).forEach(node => list.appendChild(node));
      return wraps;
    }

    function restoreCreationOrder(){
      sortWrapsBy((a, b) => {
        const aOrder = Number(a.dataset.createdAt || '0');
        const bOrder = Number(b.dataset.createdAt || '0');
        if(!Number.isFinite(aOrder) && !Number.isFinite(bOrder)) return 0;
        if(!Number.isFinite(aOrder)) return 1;
        if(!Number.isFinite(bOrder)) return -1;
        return aOrder - bOrder;
      });
    }

    function updateLayoutModeUI(){
      const isMasonry = layoutConfig.mode === 'masonry';
      if(masonryToggleBtn){
        masonryToggleBtn.classList.toggle('btn-primary', isMasonry);
        masonryToggleBtn.setAttribute('aria-pressed', String(isMasonry));
      }
    }

    function setLayoutMode(mode, { force = false, reorder = true } = {}){
      const next = mode === 'masonry' ? 'masonry' : 'flow';
      const changed = layoutConfig.mode !== next;
      layoutConfig.mode = next;
      if(reorder && next === 'flow'){
        restoreCreationOrder();
      }
      updateLayoutModeUI();
      if(changed || force){
        scheduleLayout();
      }
    }

    function getChipData(){
      if(!list) return [];
      const payload = [];
      list.querySelectorAll('.btn-item').forEach(btn=>{
        const raw = (btn.dataset.label || '').trim();
        if(!raw) return;
        const host = btn.closest('.btn-wrap');
        const orderValue = host ? Number(host.dataset.createdAt || '') : NaN;
        payload.push({
          label: raw,
          color: btn.dataset.color || null,
          scaleStage: Number(btn.dataset.scaleStage || '0'),
          display: btn.textContent || '',
          order: Number.isFinite(orderValue) ? orderValue : null
        });
      });
      return payload;
    }

    function saveChips(){
      if(!list) return;
      const payload = getChipData();
      if(payload.length){
        writeStorage(STORAGE_KEY, JSON.stringify(payload));
      }else{
        removeStorage(STORAGE_KEY);
      }
    }

    function appendChipFromData(item){
      if(!list || !item || typeof item.label!=='string') return;
      const text = item.label.trim();
      if(!text) return;
      const display = typeof item.display==='string' ? item.display : undefined;
      const orderNumeric = Number(item.order);
      const node=createChip(text, {
        color: item.color || undefined,
        skipRandom: true,
        displayText: display,
        createdAt: Number.isFinite(orderNumeric) ? orderNumeric : undefined
      });
      list.appendChild(node);
      const btn=node.querySelector('.btn-item');
      if(btn){
        const stage = Number(item.scaleStage || 0);
        applyStageToChip(btn, stage, { remeasure: true });
      }
    }

    function replaceChips(data){
      if(!list) return;
      list.innerHTML = '';
      chipSequence = 0;
      if(Array.isArray(data)) data.forEach(appendChipFromData);
      restoreCreationOrder();
      setLayoutMode('flow', { force: true, reorder: false });
      refreshChipMetrics();
      saveChips();
      if(input) input.focus();
      scheduleLayout();
    }

    function loadChips(){
      if(!list) return;
      const raw = readStorage(STORAGE_KEY);
      if(!raw) return;
      let parsed;
      try{ parsed = JSON.parse(raw); }
      catch(err){ console.warn('Local storage parse failed:', err); return; }
      if(!Array.isArray(parsed)) return;
      parsed.forEach(appendChipFromData);
      restoreCreationOrder();
      setLayoutMode('flow', { force: true, reorder: false });
      refreshChipMetrics();
      scheduleLayout();
    }

    function addFromInput(){
      const value=input.value.trim();
      if(!value) return;
      const node=createChip(value);
      list.appendChild(node);
      scheduleLayout();
      saveChips();
      input.value='';
      input.focus();
    }
    function clearAllChips(){
      if(!list) return;
      list.innerHTML='';
      chipSequence = 0;
      scheduleLayout();
      saveChips();
      if(input) input.focus();
    }
    loadChips();
    scheduleLayout();
    settingsReady = true;
    persistSettings();
    updateLayoutModeUI();

    if(masonryToggleBtn){
      masonryToggleBtn.addEventListener('click', ()=>{
        const nextMode = layoutConfig.mode === 'masonry' ? 'flow' : 'masonry';
        setLayoutMode(nextMode, { force: true });
        if(nextMode === 'flow'){
          saveChips();
        }
      });
    }

    if(exportBtn){
      exportBtn.addEventListener('click', ()=>{
        const payload = getChipData();
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = EXPORT_FILENAME;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(()=>URL.revokeObjectURL(url), 0);
      });
    }

    if(importBtn && importFileInput){
      importBtn.addEventListener('click', ()=>{
        importFileInput.value = '';
        importFileInput.click();
      });
      importFileInput.addEventListener('change', ()=>{
        const file = importFileInput.files && importFileInput.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try{
            const text = reader.result;
            const parsed = JSON.parse(typeof text === 'string' ? text : '');
            if(!Array.isArray(parsed)) throw new Error('Invalid JSON');
            replaceChips(parsed);
          }catch(err){
            console.warn('Import failed:', err);
            alert('Import failed. Please choose a valid export JSON file.');
          }finally{
            importFileInput.value = '';
          }
        };
        reader.onerror = () => {
          console.warn('Import file read error:', reader.error);
          alert('Could not read the selected file.');
          importFileInput.value = '';
        };
        reader.readAsText(file);
      });
    }

    addBtn.addEventListener('click', addFromInput);
    input.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); addFromInput(); } });

    // Delete key removes focused chip
    document.addEventListener('keydown', (e)=>{
      if((e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey && typeof e.key==='string' && e.key.toLowerCase()==='d'){
        if(isTypingContext(e.target)) return;
        e.preventDefault();
        if(window.confirm('Delete all items?')){
          clearAllChips();
        }
        return;
      }
    });
    document.addEventListener('keydown', (e)=>{
      if(e.key!=='Delete' || isTypingContext(e.target)) return;
      const active = document.activeElement;
      if(active && active.classList && active.classList.contains('btn-item')){
        e.preventDefault();
        const btn = active;
        const host = btn.closest('.btn-wrap');
        if(host){
          if(chipResizeObserver) chipResizeObserver.unobserve(btn);
          host.remove();
          scheduleLayout();
          saveChips();
        }
        input.focus();
      }
    });

    // Re-emoji existing chips
    const reEmojiBtn=document.getElementById('reEmoji');
    if(reEmojiBtn){ reEmojiBtn.addEventListener('click', ()=>{ let changed=0; list.querySelectorAll('.btn-item').forEach(btn=>{ const txt=btn.textContent||''; if(!startsWithEmoji(txt)){ const em=detectEmoji(txt); if(em){ btn.textContent=em+' '+txt; changed++; } } }); try{ reEmojiBtn.animate([{transform:'scale(1)'},{transform:'scale(1.06)'},{transform:'scale(1)'}],{duration:220}); }catch(err){} reEmojiBtn.title = changed? ('Added emojis to '+changed+' chip'+(changed===1?'':'s')) : 'No changes (nothing matched)'; refreshChipMetrics(); saveChips(); }); }

    // ===== Smoke tests (manual) =====
    function runSmokeTests(){ try{ const before=list.children.length; if(emojiToggle) emojiToggle.checked=true; ['Bug','Kaffeemaschine','Lift','YouTube','TikTok','Webseite','Computer','Netzwerk','Drucker'].forEach(t=>{ input.value=t; addFromInput(); }); const after=list.children.length; console.assert(after>=before+9, 'Should add 9 chips'); const first=list.querySelector('.btn-item'); console.assert(first && /\p{Extended_Pictographic}/u.test(first.textContent.trim().charAt(0))===true, 'First chip should start with an emoji'); first.click(); console.assert(Number(first.dataset.scaleStage||'0')===1,'First cycle should set stage 1'); first.click(); console.assert(Number(first.dataset.scaleStage||'0')===2,'Second cycle should set stage 2'); first.click(); console.assert(Number(first.dataset.scaleStage||'0')===3,'Third cycle should set stage 3'); first.click(); console.assert(Number(first.dataset.scaleStage||'0')===0,'Fourth cycle should reset stage'); document.getElementById('reEmoji').click(); console.assert(/^\p{Extended_Pictographic}\s/u.test(first.textContent)===true,'Re-emoji should keep single leading emoji'); }catch(e){ console.warn('Smoke tests issue (non-fatal):', e); } }
    try{ if(new URLSearchParams(location.search).get('tests')==='1') runSmokeTests(); }catch(_){ }
  </script>
</body>
</html>
